<!DOCTYPE html>
<html>
	<head>
		<meta charset=utf-8>
		<title>Sphereflake</title>
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
        <script src="js/three.min.js"></script>
        <script src="js/controls/OrbitControls.js"></script>
        <script src="js/CCapture.all.min.js"></script>
		<script>
            const width = 400;
            const height = 400;

            // Some helper constants
            const PI = 3.1415;
            const TwoTimesPI = 2*PI;
            const PIdiv2 = PI/2;
            const PIdiv4 = PI/4;
            const ThreeTimesPIdiv4 = 3*PIdiv4;

            // scene
            const scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0xf2c265, 0.1);

            // camera
            const camera = new THREE.PerspectiveCamera( 60, width / height, 0.1, 20 );
            camera.lookAt(0,0.5,0);
            camera.position.z = 5;
            camera.position.y = 1.3;

            const controls = new THREE.OrbitControls( camera );
            controls.enableDamping = true;

            // renderer
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setClearColor( 0xf2c265, 1 );
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.setSize( width, height );
            const canvas = renderer.domElement;
            document.body.appendChild( canvas );

            // floor
            const planeGeometry = new THREE.PlaneBufferGeometry( 40, 40 );
            const planeMaterial = new THREE.MeshStandardMaterial( { color: 0xf2c265, metalness: 0.4, roughness: 0.8 } );
            const plane = new THREE.Mesh( planeGeometry, planeMaterial );
            plane.rotation.x = -90 * (PI/180);
            plane.position.set(0, -3, 0);
            plane.receiveShadow = true;
            scene.add( plane );

            // lights
            const ambientLight = new THREE.AmbientLight( 0x808080, 0.5 );
            scene.add( ambientLight );

            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(-0.8, 1, 1);
            directionalLight.castShadow = true;
            directionalLight.shadow.camera.near = 0;
            directionalLight.shadow.camera.far = 10;
            scene.add(directionalLight);

            const directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight2.position.set(0.7, 1, 1);
            directionalLight2.castShadow = true;
            directionalLight2.shadow.camera.near = 0;
            directionalLight2.shadow.camera.far = 9;
            scene.add(directionalLight2);

            const hemisphereLight = new THREE.HemisphereLight( 0xffffbb, 0x080820, 0.6 );
            scene.add( hemisphereLight );

            function spherericalCoordsToCartesian(distance, theta, phi) {
                return {
                    x: distance * Math.sin(theta) * Math.cos(phi),
                    y: distance * Math.sin(theta) * Math.sin(phi),
                    z: distance * Math.cos(theta),
                }
            }

            function sphereflake(group, material, pos, radius, depth = 1) {
                if (depth < 0) {
                    return;
                }

                const geometry = new THREE.SphereBufferGeometry( radius, 9, 9 );
                const sphere = new THREE.Mesh( geometry, material );
                sphere.position.set( pos.x, pos.y, pos.z );
                sphere.castShadow = true;
                sphere.receiveShadow = true;
                group.add( sphere );

                const newRadius = radius/3;
                const distance = radius + newRadius;
                let newPos = spherericalCoordsToCartesian(distance, PIdiv2, PIdiv4);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);
                newPos = spherericalCoordsToCartesian(distance, PIdiv2, -PIdiv4);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);

                newPos = spherericalCoordsToCartesian(distance, -PIdiv2, PIdiv4);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);
                newPos = spherericalCoordsToCartesian(distance, -PIdiv2, -PIdiv4);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);

                newPos = spherericalCoordsToCartesian(distance, PIdiv4, PI);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);
                newPos = spherericalCoordsToCartesian(distance, -PIdiv4, PI);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);

                newPos = spherericalCoordsToCartesian(distance, ThreeTimesPIdiv4, PI);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);
                newPos = spherericalCoordsToCartesian(distance, -ThreeTimesPIdiv4, PI);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);

                newPos = spherericalCoordsToCartesian(distance, PIdiv4, PIdiv2);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);
                newPos = spherericalCoordsToCartesian(distance, PIdiv4, -PIdiv2);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);

                newPos = spherericalCoordsToCartesian(distance, ThreeTimesPIdiv4, PIdiv2);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);
                newPos = spherericalCoordsToCartesian(distance, -ThreeTimesPIdiv4, PIdiv2);
                sphereflake(group, material, {x: pos.x + newPos.x, y: pos.y + newPos.y, z: pos.z + newPos.z}, newRadius, depth-1);
            }

            // create the sphereflake, insert in "group"
            const material = new THREE.MeshPhongMaterial( { color: 0x6B9AA0, specular: 0x252525 } );
            const group = new THREE.Group();
            sphereflake(group, material, {x: 0, y: 0.3, z: 0}, 1, 3);
            scene.add(group);

            // out gif recorder
            var capturer = new CCapture( {
                format: 'gif',
                workersPath: 'js/',
                verbose: true,
                timeLimit: 1.5,
                name: 'test',
                framerate: 60,
                quality: 100,
                motionBlurFrames: 4,
            });

            // animate!
            function animate() {
                const time = (0.001 * performance.now());

                requestAnimationFrame( animate );

                group.rotation.y = time * TwoTimesPI / 12;

                controls.update();
                renderer.render( scene, camera );

                capturer.capture( canvas );
            }
            //capturer.start(); uncoment to record a gi.f
            animate();

		</script>
	</body>
</html>